{"ast":null,"code":"import n, { freeze as r } from \"immer\";\nimport { useState as t, useCallback as o, useMemo as f, useReducer as u } from \"react\";\n\nfunction i(f) {\n  var u = t(function () {\n    return r(\"function\" == typeof f ? f() : f, !0);\n  }),\n      i = u[1];\n  return [u[0], o(function (t) {\n    i(\"function\" == typeof t ? n(t) : r(t));\n  }, [])];\n}\n\nfunction e(r, t, o) {\n  var i = f(function () {\n    return n(r);\n  }, [r]);\n  return u(i, t, o);\n}\n\nexport { i as useImmer, e as useImmerReducer };","map":{"version":3,"sources":["../src/index.ts"],"names":["useImmer","initialValue","updateValue","useState","freeze","useCallback","updater","produce","useImmerReducer","reducer","initialState","initialAction","cachedReducer","useMemo","useReducer"],"mappings":";;;SAYgBA,C,CAASC,C,EAAAA;AAAAA,MAAAA,CAAAA,GACIE,CAAAA,CAAS,YAAA;AAAA,WAClCC,CAAAA,CAC0B,cAAA,OAAjBH,CAAiB,GAAaA,CAAAA,EAAb,GAA8BA,CADxDG,EACwDH,CACtD,CAFFG,CADkC;AAGhC,GAHuBD,CADJF;AAAAA,MACXC,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CADWD;AAOvB,SAAO,CAAA,CAAA,CAAA,CAAA,CAAA,EAELI,CAAAA,CAAY,UAACC,CAAD,EAACA;AACwBJ,IAAAA,CAAAA,CAAZ,cAAA,OAAZI,CAAY,GAAwBC,CAAAA,CAAQD,CAARC,CAAxB,GACNH,CAAAA,CAAOE,CAAPF,CADkBF,CAAAA;AACXI,GAF1BD,EAGG,EAHHA,CAFK,CAAP;AAKK;;AAAA,SASSG,CATT,CAULC,CAVK,EAWLC,CAXK,EAYLC,CAZK,EAYLA;AAEA,MAAMC,CAAAA,GAAgBC,CAAAA,CAAQ,YAAA;AAAA,WAAMN,CAAAA,CAAQE,CAARF,CAAN;AAAcE,GAAtBI,EAAgC,CAACJ,CAAD,CAAhCI,CAAtB;AACA,SAAOC,CAAAA,CAAWF,CAAXE,EAA0BJ,CAA1BI,EAA+CH,CAA/CG,CAAP;AAAsDH;;AAAAA,SAAAA,CAAAA,IAAAA,QAAAA,EAAAA,CAAAA,IAAAA,eAAAA","sourcesContent":["import produce, { Draft, nothing, freeze } from \"immer\";\nimport { useState, useReducer, useCallback, useMemo, Dispatch } from \"react\";\n\nexport type Reducer<S = any, A = any> = (\n  draftState: Draft<S>,\n  action: A\n) => void | (S extends undefined ? typeof nothing : S);\nexport type DraftFunction<S> = (draft: Draft<S>) => void;\nexport type Updater<S> = (arg: S | DraftFunction<S>) => void;\nexport type ImmerHook<S> = [S, Updater<S>];\nexport function useImmer<S = any>(initialValue: S | (() => S)): ImmerHook<S>;\n\nexport function useImmer(initialValue: any) {\n  const [val, updateValue] = useState(() =>\n    freeze(\n      typeof initialValue === \"function\" ? initialValue() : initialValue,\n      true\n    )\n  );\n  return [\n    val,\n    useCallback((updater) => {\n      if (typeof updater === \"function\") updateValue(produce(updater));\n      else updateValue(freeze(updater));\n    }, []),\n  ];\n}\n\nexport function useImmerReducer<S = any, A = any>(\n  reducer: Reducer<S, A>,\n  initialState: S,\n  initialAction?: (initial: any) => S\n): [S, Dispatch<A>];\nexport function useImmerReducer(\n  reducer: any,\n  initialState: any,\n  initialAction: any\n) {\n  const cachedReducer = useMemo(() => produce(reducer), [reducer]);\n  return useReducer(cachedReducer, initialState as any, initialAction);\n}\n"]},"metadata":{},"sourceType":"module"}